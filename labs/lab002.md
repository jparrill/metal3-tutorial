# Lab 2: Playing with Hosts/Machines/Nodes using BMO, cluster-api and the UserData

Ok we already have a K8s cluster deployed on "Baremetal" and we have 1 node which is the control plane and 2 more BareMetal nodes deployed on LibVirt and ready to be managed by Kubernetes. For now they are not doing anything itself. 

Now we will see how to integrate those nodes into the deployed cluster and play with them.

**DISCLAIMER:** This header is just for our own purpose. If you find it during the laboratory, don't worry about, **you don't need execute it!**:

```bash @mdsh
mdsh-lang-bash() { shell; }
```

## Some theory to know before start the lab

The BareMetal Operator (BMO) is one of the most important pieces of Metal³, It cares about link BareMetalHosts with physical/virtual nodes through Ironic and IPMI, then stablish the relationship between the BareMetalHosts and Machines in order to perform a deployment into this physical/virtual host. 

Let's see what's the difference between some objects that could confuse you.

### BareMetalHost vs Machine vs Node

Here we have 3 separated objects:

- **Node** objects represent a running instance of kubelet. Their status fields include basic information about the health of the environment in which kubelet is running.
- **Machine** objects represent a request for an instance of kubelet. Machine objects include a "provider spec" field to allow the actuator to store custom data. The lifecycle of a Machine is based on the desired size of the cluster (CR Managed by cluster-api Controller)
- The **BareMetalHost** resource defines the properties of a physical host necessary to manage and provision it. (CR Managed by BareMetal Operator)

#### Reference: [Nodes, Machines and Hosts](https://github.com/metal3-io/metal3-docs/blob/master/design/nodes-machines-and-hosts.md#data-model)

### Workflow

The proper workflow to make this work is create a BareMetalHost CR with all the details but without `userData`, then wait for BMO to get the node in **Ready** state.

After that create a Machine CR in order to create a link between the BareMetalHost and the Machine (declared on the **CONSUMER** field). To do this we need that the Machine manifest use a **secret** from K8s which contains the UserData to deploy kubernetes in the new node and let him join to the K8s cluster


## Hands in Lab



### Scripts & Utilities

Now we have some script that could be very useful to work with our VMs

- `create_machine.sh` - Creates a new **Machine** definition on K8s API, then BMO check that a new object exists and needs to make it real. It uses ironic to provision the machine.
- `provision_host.sh` - Creates a new **BareMetalHost**, depending on the manifest the BMH will be also provisioned with a concrete user-data. In this case the BMH created is just a CentOS7 basic node.


### Other tools

- `make-bm-worker` - This is not a script that exists on the repo, it's just a dependency downloaded during the k8s deployment, to execute it do this:
```
go run $GOPATH/src/github.com/metal3-io/baremetal-operator/cmd/make-bm-worker/main.go -address ipmi://192.168.111.1:6232 -password password -user admin -boot-mac 00:6c:f2:66:00:fc worker-1 | kubectl create -n metal3 -f -
```
  This script will create a new BareMetalHost on Ironic, and also on K8s API in order to let BMO connect to the ipmi address and then boot it up, provision it and so on, but it needs to exists previously on the destination provider, Libvirt in this case. If the VM does not exists you will get this error:
  ```
  Failed to get power state for node "NODE ID". Error: IPMI call failed: power status
  ```
  Other thing that you need to have in mind is the user-data, here we are not injecting any useful data. check the `user_data.sh` script to know how Metal³ folks inject the data. 

